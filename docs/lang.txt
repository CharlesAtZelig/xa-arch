
This is a proposed, conceptual, representation of table-transforming
rules for Lichen. The syntax is line-oriented but could be changed to
another representation (like JSON). The names of operations are
capitalized in this example, but this is possibly not required were a
different representation used.

This will be implemented with an interpreter library in the xa-rules
repository. Users of the library (Lichen, for example) may also inject
additional tables and code modules before executing the rule.

| ACTION                                   | EFFECT                                                                                           |
|------------------------------------------+--------------------------------------------------------------------------------------------------|
| EXPECT foo[x, y, z]                      | Anticipate a table in the environment named "foo" having at least "x", "y", "z" as columns       |
| COMMIT foo[x, y, z]                      | Record the values in x, y, z as permanent changes to table foo                                   |
| ATTACH repo.lichen.org AS lichen         | Use repo.lichen.org as a Repository named "lichen"                                               |
| GET lichen:rule0:1234 AS foo             | Load a rule as a table from the "lichen" repo                                                    |
| USE foo                                  | Use the table named "foo" as the current table that actions will target                          |
| APPLY bar USING <func>(x, y) [DEFAULT z] | In the table bar where bar.y == foo.x, apply the function "func", replacing all matching columns |
| REQUIRE lichen:rule0:1234 AS z           | Load a rule as executable code from the repo                                                     |
| MAP bar USING z.f                        | Same as MAP above, except the function f in the required module z is called                      |
| FILTER foo USING z.f                     | Reduce the rows in foo in the function f                                                         |


Internal functions for MAP:
 - copy: copies the values from the mapped table
 - multiply: multiplies by the values from the mapped table
 - divide: divides by the values from the mapped table
 - add: adds the values from the mapped table
 - subtract: subtracts the values from the mapped table
 - concat: string concatenates the values from the mapped table

Example:

Table: foo

| A | B | C |  D |
|---+---+---+----|  << Remove these from all tables.
| 1 | 2 | 3 |  4 |
| 2 | 4 | 6 |  8 |
| 3 | 6 | 9 | 12 |

Table: bar

| X |  C | D |
|---+----+---|
| 1 |  4 | 3 |
| 2 | 10 | 9 |

Table: baz

| Q |  C |
|---+----|
| 1 |  5 |
| 2 |  2 |
| 3 | 10 |

Rule:

USE foo
APPLY bar USING copy(A, X) DEFAULT 100
APPLY baz USING add(A, Q)


At this point, this is "foo":

| A | B |   C |   D |
|---+---+-----+-----|
| 1 | 2 |   9 |   3 |
| 2 | 4 |  12 |   9 |
| 3 | 6 | 110 | 100 |


USE baz
APPLY foo USING copy(Q, B) DEFAULT 1

Now we have modofied "baz" to get:

| Q | C |
|---+---|
| 1 | 1 |
| 2 | 9 |
| 3 | 1 |

This could also be represented in JSON:

[
  { "use" : "foo" },
  { "apply" : { "bar" : ["copy", ["A", "X"], 100] } },
  { "apply" : { "baz" : ["add", ["A, "Q"]] } },
]
